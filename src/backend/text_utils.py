"""Utilities to clean up legacy mojibake strings from historical data."""

from __future__ import annotations

from typing import Any, Dict

_TEXT_FIXUPS: Dict[str, str] = {
    "Prometheus ????? ?????????? ???? ?????? ??? ??? ???? ????????.": "Prometheus 대시보드에서 최근 배포와 메트릭 변화를 교차 확인하세요.",
    "????/?????? ???? ????? ?????? ??????? ????? ???": "사후 분석 회의를 열고 근본 원인과 재발 방지 대책을 문서화하세요.",
    "??? ???? ?????? ?????????.": "조치 플레이북의 초기 점검 절차를 수행하세요.",
    "????? ??? ????? ???? ?????? ???? ???? ???? ?????? ??????.": "서비스 지연과 오류로 고객에게 영향이 갔을 가능성이 있습니다.",
    "- (??? ?? ??? ????.)": "- (추가 실행 계획 없음)",
}


def normalize_legacy_text(value: str) -> str:
    """Replace known mojibake fragments with their intended Korean text."""

    if not isinstance(value, str) or not value:
        return value

    fixed = value
    for legacy, replacement in _TEXT_FIXUPS.items():
        if legacy in fixed:
            fixed = fixed.replace(legacy, replacement)
    return fixed


def normalize_legacy_payload(obj: Any) -> Any:
    """Recursively normalise strings inside dict/list payloads."""

    if isinstance(obj, str):
        return normalize_legacy_text(obj)
    if isinstance(obj, list):
        return [normalize_legacy_payload(item) for item in obj]
    if isinstance(obj, tuple):
        return tuple(normalize_legacy_payload(item) for item in obj)
    if isinstance(obj, dict):
        return {key: normalize_legacy_payload(value) for key, value in obj.items()}
    return obj
